"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MigrateEngine_exports = {};
__export(MigrateEngine_exports, {
  EngineError: () => EngineError,
  MigrateEngine: () => MigrateEngine
});
module.exports = __toCommonJS(MigrateEngine_exports);
var import_debug = __toESM(require("@prisma/debug"));
var import_internals = require("@prisma/internals");
var import_chalk = __toESM(require("chalk"));
var import_child_process = require("child_process");
var import_path = __toESM(require("path"));
var import_byline = __toESM(require("./utils/byline"));
const debugRpc = (0, import_debug.default)("prisma:migrateEngine:rpc");
const debugStderr = (0, import_debug.default)("prisma:migrateEngine:stderr");
const debugStdin = (0, import_debug.default)("prisma:migrateEngine:stdin");
class EngineError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
__name(EngineError, "EngineError");
let messageId = 1;
class MigrateEngine {
  constructor({ projectDir, debug = false, schemaPath, enabledPreviewFeatures }) {
    this.listeners = {};
    this.messages = [];
    this.lastError = null;
    this.isRunning = false;
    this.projectDir = projectDir;
    this.schemaPath = schemaPath;
    if (debug) {
      import_debug.default.enable("MigrateEngine*");
    }
    this.debug = debug;
    this.enabledPreviewFeatures = enabledPreviewFeatures;
  }
  applyMigrations(args) {
    return this.runCommand(this.getRPCPayload("applyMigrations", args));
  }
  createDatabase(args) {
    return this.runCommand(this.getRPCPayload("createDatabase", args));
  }
  createMigration(args) {
    return this.runCommand(this.getRPCPayload("createMigration", args));
  }
  dbExecute(args) {
    return this.runCommand(this.getRPCPayload("dbExecute", args));
  }
  debugPanic() {
    return this.runCommand(this.getRPCPayload("debugPanic", void 0));
  }
  devDiagnostic(args) {
    return this.runCommand(this.getRPCPayload("devDiagnostic", args));
  }
  diagnoseMigrationHistory(args) {
    return this.runCommand(this.getRPCPayload("diagnoseMigrationHistory", args));
  }
  ensureConnectionValidity(args) {
    return this.runCommand(this.getRPCPayload("ensureConnectionValidity", args));
  }
  evaluateDataLoss(args) {
    return this.runCommand(this.getRPCPayload("evaluateDataLoss", args));
  }
  getDatabaseDescription(schema) {
    return this.runCommand(this.getRPCPayload("getDatabaseDescription", { schema }));
  }
  getDatabaseVersion() {
    return this.runCommand(this.getRPCPayload("getDatabaseVersion", { schema: this.schemaPath }));
  }
  async introspect({
    schema,
    force = false,
    compositeTypeDepth = -1,
    schemas
  }) {
    this.latestSchema = schema;
    try {
      const introspectResult = await this.runCommand(
        this.getRPCPayload("introspect", { schema, force, compositeTypeDepth, schemas })
      );
      const { views } = introspectResult;
      if (views) {
        const schemaPath = this.schemaPath ?? import_path.default.join(process.cwd(), "prisma");
        await (0, import_internals.handleViewsIO)({ views, schemaPath });
      }
      return introspectResult;
    } finally {
      this.stop();
    }
  }
  migrateDiff(args) {
    return this.runCommand(this.getRPCPayload("diff", args));
  }
  listMigrationDirectories(args) {
    return this.runCommand(this.getRPCPayload("listMigrationDirectories", args));
  }
  markMigrationApplied(args) {
    return this.runCommand(this.getRPCPayload("markMigrationApplied", args));
  }
  markMigrationRolledBack(args) {
    return this.runCommand(this.getRPCPayload("markMigrationRolledBack", args));
  }
  reset() {
    return this.runCommand(this.getRPCPayload("reset", void 0));
  }
  schemaPush(args) {
    return this.runCommand(this.getRPCPayload("schemaPush", args));
  }
  stop() {
    if (this.child) {
      this.child.kill();
      this.isRunning = false;
    }
  }
  rejectAll(err) {
    Object.entries(this.listeners).map(([id, listener]) => {
      listener(null, err);
      delete this.listeners[id];
    });
  }
  registerCallback(id, callback) {
    this.listeners[id] = callback;
  }
  handleResponse(response) {
    let result;
    try {
      result = JSON.parse(response);
    } catch (e) {
      console.error(`Could not parse migration engine response: ${response.slice(0, 200)}`);
    }
    if (result) {
      if (result.id && (result.result !== void 0 || result.error !== void 0)) {
        if (!this.listeners[result.id]) {
          console.error(`Got result for unknown id ${result.id}`);
        }
        if (this.listeners[result.id]) {
          this.listeners[result.id](result);
          delete this.listeners[result.id];
        }
      } else if (result.method) {
        if (result.id !== void 0) {
          if (result.method === "print" && result.params?.content !== void 0) {
            console.info(result.params.content);
            const response2 = {
              id: result.id,
              jsonrpc: "2.0",
              result: {}
            };
            this.child.stdin.write(JSON.stringify(response2) + "\n");
          }
        }
      }
    }
  }
  init() {
    if (!this.initPromise) {
      this.initPromise = this.internalInit();
    }
    return this.initPromise;
  }
  internalInit() {
    return new Promise(async (resolve, reject) => {
      try {
        const { PWD, ...processEnv } = process.env;
        const binaryPath = await (0, import_internals.resolveBinary)(import_internals.BinaryType.MigrationEngineBinary);
        debugRpc("starting migration engine with binary: " + binaryPath);
        const args = [];
        if (this.schemaPath) {
          args.push(...["-d", this.schemaPath]);
        }
        if (this.enabledPreviewFeatures && Array.isArray(this.enabledPreviewFeatures) && this.enabledPreviewFeatures.length > 0) {
          args.push(...["--enabled-preview-features", this.enabledPreviewFeatures.join(",")]);
        }
        this.child = (0, import_child_process.spawn)(binaryPath, args, {
          cwd: this.projectDir,
          stdio: ["pipe", "pipe", this.debug ? process.stderr : "pipe"],
          env: {
            RUST_LOG: "info",
            RUST_BACKTRACE: "1",
            ...processEnv
          }
        });
        this.isRunning = true;
        this.child.on("error", (err) => {
          console.error("[migration-engine] error: %s", err);
          this.rejectAll(err);
          reject(err);
        });
        this.child.on("exit", (code) => {
          const exitWithErr = /* @__PURE__ */ __name((err) => {
            this.rejectAll(err);
            reject(err);
          }, "exitWithErr");
          const processMessages = this.messages.join("\n");
          const engineMessage = this.lastError?.message || processMessages;
          const handlePanic = /* @__PURE__ */ __name(() => {
            const stackTrace = `[EXIT_PANIC]
${processMessages}
${this.lastError?.backtrace ?? ""}`;
            exitWithErr(
              new import_internals.RustPanic(
                serializePanic(engineMessage),
                stackTrace,
                this.lastRequest,
                import_internals.ErrorArea.LIFT_CLI,
                this.schemaPath,
                this.latestSchema
              )
            );
          }, "handlePanic");
          switch (code) {
            case import_internals.MigrateEngineExitCode.Success:
              break;
            case import_internals.MigrateEngineExitCode.Error:
              exitWithErr(new Error(`Error in migration engine: ${engineMessage}`));
              break;
            case import_internals.MigrateEngineExitCode.Panic:
              handlePanic();
              break;
            default:
              handlePanic();
          }
        });
        this.child.stdin.on("error", (err) => {
          debugStdin(err);
        });
        (0, import_byline.default)(this.child.stderr).on("data", (msg) => {
          const data = String(msg);
          debugStderr(data);
          try {
            const json = JSON.parse(data);
            this.messages.push(json.fields.message);
            if (json.level === "ERROR") {
              this.lastError = json.fields;
            }
          } catch (e) {
          }
        });
        (0, import_byline.default)(this.child.stdout).on("data", (line) => {
          this.handleResponse(String(line));
        });
        setImmediate(() => {
          resolve();
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  async runCommand(request) {
    if (process.env.FORCE_PANIC_MIGRATION_ENGINE) {
      request = this.getRPCPayload("debugPanic", void 0);
    }
    await this.init();
    if (this.child?.killed) {
      throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine already exited.`);
    }
    return new Promise((resolve, reject) => {
      this.registerCallback(request.id, (response, err) => {
        if (err) {
          return reject(err);
        }
        if (response.result !== void 0) {
          resolve(response.result);
        } else {
          if (response.error) {
            debugRpc(response);
            if (response.error.data?.is_panic) {
              const message = response.error.data?.error?.message ?? response.error.message;
              const stackTrace = `[RESPONSE_ERROR_PANIC]
${response.error.data?.message ?? ""}`;
              reject(
                new import_internals.RustPanic(
                  message,
                  stackTrace,
                  this.lastRequest,
                  import_internals.ErrorArea.LIFT_CLI,
                  this.schemaPath,
                  this.latestSchema
                )
              );
            } else if (response.error.data?.message) {
              let message = `${import_chalk.default.redBright(response.error.data.message)}
`;
              if (response.error.data?.error_code) {
                message = import_chalk.default.redBright(`${response.error.data.error_code}

`) + message;
                reject(new EngineError(message, response.error.data.error_code));
              } else {
                reject(new Error(message));
              }
            } else {
              reject(
                new Error(
                  `${import_chalk.default.redBright("Error in RPC")}
 Request: ${JSON.stringify(
                    request,
                    null,
                    2
                  )}
Response: ${JSON.stringify(response, null, 2)}
${response.error.message}
`
                )
              );
            }
          } else {
            reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
          }
        }
      });
      if (this.child.stdin.destroyed) {
        throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine is destroyed.`);
      }
      debugRpc("SENDING RPC CALL", JSON.stringify(request));
      this.child.stdin.write(JSON.stringify(request) + "\n");
      this.lastRequest = request;
    });
  }
  getRPCPayload(method, params) {
    return {
      id: messageId++,
      jsonrpc: "2.0",
      method,
      params: {
        ...params
      }
    };
  }
}
__name(MigrateEngine, "MigrateEngine");
function serializePanic(log) {
  return `${import_chalk.default.red.bold("Error in migration engine.\nReason: ")}${log}

Please create an issue with your \`schema.prisma\` at
${import_chalk.default.underline("https://github.com/prisma/prisma/issues/new")}
`;
}
__name(serializePanic, "serializePanic");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EngineError,
  MigrateEngine
});
