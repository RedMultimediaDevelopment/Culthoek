"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ensureDatabaseExists_exports = {};
__export(ensureDatabaseExists_exports, {
  ensureCanConnectToDatabase: () => ensureCanConnectToDatabase,
  ensureDatabaseExists: () => ensureDatabaseExists,
  getDatasourceInfo: () => getDatasourceInfo,
  getDbLocation: () => getDbLocation,
  prettifyProvider: () => prettifyProvider
});
module.exports = __toCommonJS(ensureDatabaseExists_exports);
var import_internals = require("@prisma/internals");
var import_chalk = __toESM(require("chalk"));
async function getDatasourceInfo({
  schemaPath,
  throwIfEnvError
} = {}) {
  const schema = await (0, import_internals.getSchema)(schemaPath);
  let config;
  try {
    config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: false });
  } catch (error) {
    if (throwIfEnvError) {
      throw error;
    }
    config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: true });
  }
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    return {
      name: void 0,
      prettyProvider: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url: void 0,
      schema: void 0,
      schemas: void 0
    };
  }
  const prettyProvider = prettifyProvider(firstDatasource.provider);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  if (!url || firstDatasource.provider === "sqlserver") {
    return {
      name: firstDatasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url: url || void 0,
      schema: void 0,
      schemas: firstDatasource.schemas
    };
  }
  try {
    const credentials = (0, import_internals.uriToCredentials)(url);
    const dbLocation = getDbLocation(credentials);
    let schema2 = void 0;
    if (["postgresql", "cockroachdb"].includes(firstDatasource.provider)) {
      if (credentials.schema) {
        schema2 = credentials.schema;
      } else {
        schema2 = "public";
      }
    }
    const datasourceInfo = {
      name: firstDatasource.name,
      prettyProvider,
      dbName: credentials.database,
      dbLocation,
      url,
      schema: schema2,
      schemas: firstDatasource.schemas
    };
    if (firstDatasource.provider === "postgresql" && datasourceInfo.dbName === void 0) {
      datasourceInfo.dbName = "postgres";
    }
    return datasourceInfo;
  } catch (e) {
    return {
      name: firstDatasource.name,
      prettyProvider,
      dbName: void 0,
      dbLocation: void 0,
      url,
      schema: void 0,
      schemas: firstDatasource.schemas
    };
  }
}
__name(getDatasourceInfo, "getDatasourceInfo");
async function ensureCanConnectToDatabase(schemaPath) {
  const schema = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: false });
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = await (0, import_internals.getSchemaDir)(schemaPath);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return true;
  } else {
    const { code, message } = canConnect;
    throw new Error(`${code}: ${message}`);
  }
}
__name(ensureCanConnectToDatabase, "ensureCanConnectToDatabase");
async function ensureDatabaseExists(action, schemaPath) {
  const schema = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel: schema, ignoreEnvVarErrors: false });
  const firstDatasource = config.datasources[0] ? config.datasources[0] : void 0;
  if (!firstDatasource) {
    throw new Error(`A datasource block is missing in the Prisma schema file.`);
  }
  const schemaDir = await (0, import_internals.getSchemaDir)(schemaPath);
  const url = (0, import_internals.getEffectiveUrl)(firstDatasource).value;
  const canConnect = await (0, import_internals.canConnectToDatabase)(url, schemaDir);
  if (canConnect === true) {
    return;
  }
  const { code, message } = canConnect;
  if (code !== "P1003") {
    throw new Error(`${code}: ${message}`);
  }
  if (!schemaDir) {
    throw new Error(`Could not locate ${schemaPath || "schema.prisma"}`);
  }
  if (await (0, import_internals.createDatabase)(url, schemaDir)) {
    if (firstDatasource.provider === "sqlserver") {
      return `SQL Server database created.
`;
    }
    const credentials = (0, import_internals.uriToCredentials)(url);
    const prettyProvider = prettifyProvider(firstDatasource.provider);
    let message2 = `${prettyProvider} database${credentials.database ? ` ${credentials.database} ` : " "}created`;
    const dbLocation = getDbLocation(credentials);
    if (dbLocation) {
      message2 += ` at ${import_chalk.default.bold(getDbLocation(credentials))}`;
    }
    return message2;
  }
  return void 0;
}
__name(ensureDatabaseExists, "ensureDatabaseExists");
function getDbLocation(credentials) {
  if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  if (credentials.host && credentials.port) {
    return `${credentials.host}:${credentials.port}`;
  } else if (credentials.host) {
    return `${credentials.host}`;
  }
  return void 0;
}
__name(getDbLocation, "getDbLocation");
function prettifyProvider(provider) {
  switch (provider) {
    case "mysql":
      return `MySQL`;
    case "postgres":
    case "postgresql":
      return `PostgreSQL`;
    case "sqlite":
      return `SQLite`;
    case "cockroachdb":
      return `CockroachDB`;
    case "sqlserver":
      return `SQL Server`;
    case "mongodb":
      return `MongoDB`;
    default:
      return provider;
  }
}
__name(prettifyProvider, "prettifyProvider");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ensureCanConnectToDatabase,
  ensureDatabaseExists,
  getDatasourceInfo,
  getDbLocation,
  prettifyProvider
});
